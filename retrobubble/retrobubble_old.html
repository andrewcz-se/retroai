<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Bubble</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        :root {
            --game-width: 800px;
            --game-height: 600px;
            --font-stack: 'Press Start 2P', cursive;
            --primary-color: #00ffcc;
            --secondary-color: #ff00ff;
            --background-color: #1a1a2e;
            --text-color: #ffffff;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-align: center;
        }

        .game-container {
            position: relative;
            width: var(--game-width);
            height: var(--game-height);
            box-shadow: 0 0 20px var(--primary-color), 0 0 30px var(--secondary-color) inset;
            border: 4px solid var(--primary-color);
            border-radius: 15px; /* Added for screen curve */
            background: #000;
            overflow: hidden; /* Ensures effects stay within the curve */
        }
        
        /* CRT Glow Effect */
        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            box-shadow: 0 0 60px 10px var(--primary-color) inset, 0 0 10px 5px var(--secondary-color) inset;
            pointer-events: none;
            z-index: 5;
        }
        
        /* CRT Scanline Effect */
        .game-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.3) 0px,
                rgba(0, 0, 0, 0.3) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 12;
        }

        canvas {
            display: block;
            background-color: #111;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Ensures pixel art isn't blurry */
        }

        .ui {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 16px;
            pointer-events: none;
            text-shadow: 2px 2px var(--secondary-color);
            z-index: 11; /* Make sure UI is above glow but below scanlines */
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--text-color);
            z-index: 10;
        }

        .game-overlay h1 {
            font-size: 48px;
            color: var(--primary-color);
            text-shadow: 3px 3px var(--secondary-color);
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
        }
        
        .game-overlay p {
            font-size: 18px;
            margin-bottom: 30px;
        }

        .game-overlay .start-button {
            font-family: var(--font-stack);
            font-size: 20px;
            padding: 15px 30px;
            background-color: var(--primary-color);
            color: var(--background-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-shadow: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .game-overlay .start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--primary-color);
        }
        
        .hidden {
            display: none;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="ui">
            <div id="score">SCORE: 0</div>
            <div id="level">LEVEL: 1</div>
            <div id="lives">LIVES: 3</div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="startScreen" class="game-overlay">
            <h1 id="loadingText">Loading Sprites...</h1>
            <p id="instructions" class="hidden">Arrow Keys to Move - Space to Shoot Bubbles</p>
            <button class="start-button hidden" id="startButton">Start Game</button>
        </div>
        <div id="gameOverScreen" class="game-overlay hidden">
            <h1>Game Over</h1>
            <p id="finalScore">Your Score: 0</p>
            <button class="start-button" id="restartButton">Restart</button>
        </div>
        <div id="levelCompleteScreen" class="game-overlay hidden">
             <h1>Level Clear!</h1>
             <p id="levelBonus">Bonus: 0</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI Elements
            const scoreEl = document.getElementById('score');
            const levelEl = document.getElementById('level');
            const livesEl = document.getElementById('lives');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const levelCompleteScreen = document.getElementById('levelCompleteScreen');
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const finalScoreEl = document.getElementById('finalScore');
            const levelBonusEl = document.getElementById('levelBonus');
            const loadingText = document.getElementById('loadingText');
            const instructions = document.getElementById('instructions');
            
            canvas.width = 800;
            canvas.height = 600;

            // --- Game State ---
            let score = 0;
            let lives = 3;
            let level = 1;
            let isGameOver = false;
            let gameStarted = false;
            let spritesLoaded = false;
            let currentBackground = null;
            let attractModeAI = {
                active: false,
                changeDirectionTimer: 120,
                jumpTimer: 180,
                shootTimer: 90
            };

            const keys = {
                ArrowLeft: false,
                ArrowRight: false,
                ArrowUp: false,
                Space: false
            };

            // --- Game Constants ---
            const GRAVITY = 0.5;
            const PLAYER_SPEED = 5;
            const PLAYER_JUMP_FORCE = 13.5;
            const BUBBLE_SPEED = 6;
            const BUBBLE_LIFESPAN = 300; // frames
            const ENEMY_TRAPPED_DURATION = 400; // frames

            // --- Sound Engine (Tone.js) ---
            const synth = new Tone.PolySynth(Tone.Synth).toDestination();
            synth.volume.value = -6;
            const sounds = {
                jump: () => synth.triggerAttackRelease("C5", "8n"),
                shoot: () => synth.triggerAttackRelease("G4", "16n"),
                pop: () => synth.triggerAttackRelease("E5", "8n"),
                enemyHit: () => synth.triggerAttackRelease("A4", "16n"),
                playerHit: () => synth.triggerAttackRelease("C3", "4n"),
                collect: () => synth.triggerAttackRelease("C6", "16n"),
                levelClear: () => {
                    const now = Tone.now();
                    synth.triggerAttackRelease("C5", "8n", now);
                    synth.triggerAttackRelease("E5", "8n", now + 0.2);
                    synth.triggerAttackRelease("G5", "8n", now + 0.4);
                }
            };
            
            // --- Sprite & Animation Engine ---
            const sprites = {
                player: new Image(),
                monster: new Image(),
                bubble: new Image(),
                bonus: new Image(),
                flying_monster: new Image(),
                flying_monster_trapped: new Image(),
                background_level_1: new Image(),
                background_level_2: new Image(),
                background_level_3: new Image(),
                background_level_4: new Image(),
                background_level_5: new Image(),
                background_level_6: new Image(),
                background_level_7: new Image(),
                background_level_8: new Image(),
                background_level_9: new Image(),
                background_level_10: new Image(),
            };

            const spriteSources = {
                player: 'player_sprites.png',
                monster: 'monster_sprites.png',
                bubble: 'bubble_sprites.png',
                bonus: 'bonus_sprites.png',
                flying_monster: 'flying_monster.png',
                flying_monster_trapped: 'flying_monster_trapped.png',
                background_level_1: 'background_level_1.jpg',
                background_level_2: 'background_level_2.jpg',
                background_level_3: 'background_level_3.jpg',
                background_level_4: 'background_level_4.jpg',
                background_level_5: 'background_level_5.jpg',
                background_level_6: 'background_level_6.jpg',
                background_level_7: 'background_level_7.jpg',
                background_level_8: 'background_level_8.jpg',
                background_level_9: 'background_level_9.jpg',
                background_level_10: 'background_level_10.jpg',
            };
            
            const animationData = {
                player: {
                    frameWidth: 48,
                    frameHeight: 48,
                    gap: 3,
                    animations: {
                        idleLeft:       { startFrame: 0,  frames: 2, speed: 20 },
                        walkLeft:       { startFrame: 2,  frames: 4, speed: 8 },
                        jumpLeft:       { startFrame: 6,  frames: 2, speed: 10 },
                        shootLeft:      { startFrame: 8,  frames: 1, speed: 1 },
                        shootRight:     { startFrame: 9,  frames: 1, speed: 1 },
                        jumpRight:      { startFrame: 10, frames: 2, speed: 10 },
                        walkRight:      { startFrame: 12, frames: 4, speed: 8 },
                        idleRight:      { startFrame: 16, frames: 2, speed: 20 }
                    }
                },
                monster: {
                    frameWidth: 48,
                    frameHeight: 48,
                    gap: 7,
                    animations: {
                        walkLeft:       { startFrame: 0,  frames: 4, speed: 12 },
                        angryLeft:      { startFrame: 4,  frames: 4, speed: 6 },
                        angryRight:     { startFrame: 8, frames: 4, speed: 6 },
                        walkRight:      { startFrame: 12,  frames: 4, speed: 12 }
                    }
                },
                flying_monster: {
                    frameWidth: 48,
                    frameHeight: 48,
                    gap: 12,
                    animations: {
                        flyLeft: { startFrame: 0, frames: 4, speed: 8},
                        angryFlyLeft: { startFrame: 4, frames: 4, speed: 4}
                    }
                },
                 flying_monster_trapped: {
                    frameWidth: 42,
                    frameHeight: 48,
                    gap: 12,
                    animations: {
                        trapped: { startFrame: 0, frames: 3, speed: 10 }
                    }
                },
                bubble: {
                    frameWidth: 42,
                    frameHeight: 48,
                    gap: 12,
                    animations: {
                        trapped: { startFrame: 0, frames: 3, speed: 10 },
                        normal:  { startFrame: 3, frames: 1, speed: 1 }
                    }
                },
                bonus: {
                    frameWidth: 48,
                    frameHeight: 48,
                    gap: 7,
                    animations: {
                        orange:      { startFrame: 0, frames: 1, speed: 1 },
                        lemon:       { startFrame: 1, frames: 1, speed: 1 },
                        watermelon:  { startFrame: 2, frames: 1, speed: 1 },
                        cherry:      { startFrame: 3, frames: 1, speed: 1 },
                        strawberry:  { startFrame: 4, frames: 1, speed: 1 }
                    }
                }
            };
            
            const bonusTypes = ['orange', 'lemon', 'watermelon', 'cherry', 'strawberry'];


            function loadSprites() {
                let loadedCount = 0;
                const totalSprites = Object.keys(sprites).length;
                
                const onSpriteLoadOrError = () => {
                    loadedCount++;
                    if (loadedCount === totalSprites) {
                        spritesLoaded = true;
                        loadingText.textContent = 'Retro Bubble';
                        instructions.classList.remove('hidden');
                        startButton.classList.remove('hidden');
                        attractModeAI.active = true;
                    }
                };

                for (let key in sprites) {
                    sprites[key].onload = onSpriteLoadOrError;
                    sprites[key].onerror = () => {
                        console.error(`Sprite "${key}" failed to load from ${spriteSources[key]}`);
                        onSpriteLoadOrError();
                    };
                    sprites[key].src = spriteSources[key];
                }
            }


            // --- Game Objects ---
            let player;
            let bubbles = [];
            let enemies = [];
            let platforms = [];
            let collectibles = [];
            
            // --- Helper Functions ---
            function checkCollision(rect1, rect2) {
                return (
                    rect1.x < rect2.x + rect2.w &&
                    rect1.x + rect1.w > rect2.x &&
                    rect1.y < rect2.y + rect2.h &&
                    rect1.y + rect1.h > rect2.y
                );
            }

            // --- Classes ---
            class Animator {
                constructor(entity, spriteKey) {
                    this.entity = entity;
                    this.spriteKey = spriteKey;
                    this.data = animationData[spriteKey];
                    this.sprite = sprites[spriteKey];
                    this.currentAnimation = null;
                    this.currentFrame = 0;
                    this.frameTimer = 0;
                }

                setAnimation(name) {
                    if (this.currentAnimation === name) return;
                    this.currentAnimation = name;
                    this.currentFrame = 0;
                    this.frameTimer = 0;
                }

                update() {
                    if (!this.currentAnimation) return;

                    let animationName = this.currentAnimation;
                    if (animationName.includes('Right')) {
                        animationName = animationName.replace('Right', 'Left');
                    }
                    
                    const anim = this.data.animations[animationName];
                    if (!anim) return;

                    this.frameTimer++;
                    if (this.frameTimer >= anim.speed) {
                        this.frameTimer = 0;
                        this.currentFrame = (this.currentFrame + 1) % anim.frames;
                    }
                }

                draw(ctx, x, y, w, h) {
                    let animationName = this.currentAnimation;
                    let flip = false;
                    
                    if (animationName && animationName.includes('Right')) {
                        animationName = animationName.replace('Right', 'Left');
                        flip = true;
                    }
                    
                    const anim = this.data.animations[animationName];

                    if (!animationName || !anim || !this.sprite.complete || this.sprite.naturalWidth === 0) {
                        ctx.fillStyle = this.spriteKey === 'player' ? 'lime' : 'red';
                        ctx.fillRect(x, y, w, h);
                        return;
                    }

                    const sourceX = (anim.startFrame + this.currentFrame) * (this.data.frameWidth + this.data.gap);
                    const sourceY = 0;

                    if (flip) {
                        ctx.save();
                        ctx.scale(-1, 1);
                        ctx.drawImage(
                            this.sprite,
                            sourceX, sourceY, this.data.frameWidth, this.data.frameHeight,
                            -x - w, y, w, h
                        );
                        ctx.restore();
                    } else {
                        ctx.drawImage(
                            this.sprite,
                            sourceX, sourceY, this.data.frameWidth, this.data.frameHeight,
                            x, y, w, h
                        );
                    }
                }
            }
            
            class Player {
                constructor() {
                    this.w = 52;
                    this.h = 52;
                    this.dy = 0;
                    this.isJumping = false;
                    this.canJump = true;
                    this.direction = 'right';
                    this.invincible = false;
                    this.invincibleTimer = 0;
                    this.isShooting = false;
                    this.shootTimer = 0;
                    this.ridingBubble = null;

                    this.animator = new Animator(this, 'player');
                    this.reset();
                }

                reset() {
                    const startPlatform = platforms[platforms.length - 1];
                    this.x = startPlatform.x + startPlatform.w / 2 - this.w / 2;
                    this.y = startPlatform.y - this.h;
                    this.dx = 0;
                    this.direction = 'right';
                    this.setAnimationState();
                }

                draw() {
                    if (this.invincible && Math.floor(this.invincibleTimer / 10) % 2 === 0) {
                        return; // Flashing effect
                    }
                    this.animator.draw(ctx, this.x, this.y, this.w, this.h);
                }
                
                setAnimationState() {
                    const dir = this.direction.charAt(0).toUpperCase() + this.direction.slice(1);

                    if (this.isShooting) {
                        this.animator.setAnimation(`shoot${dir}`);
                        return;
                    }
                    if (this.isJumping || this.ridingBubble) {
                        this.animator.setAnimation(`jump${dir}`);
                        return;
                    }
                    if (this.dx !== 0) {
                        this.animator.setAnimation(`walk${dir}`);
                        return;
                    }
                    this.animator.setAnimation(`idle${dir}`);
                }

                update() {
                    if (attractModeAI.active) {
                        this.updateAI();
                    } else {
                        this.updatePlayerControlled();
                    }
                }
                
                updatePlayerControlled() {
                    if (keys.ArrowLeft) {
                        this.dx = -PLAYER_SPEED;
                        this.direction = 'left';
                    } else if (keys.ArrowRight) {
                        this.dx = PLAYER_SPEED;
                        this.direction = 'right';
                    } else {
                        this.dx = 0;
                    }
                    if (keys.ArrowUp && this.canJump && !this.isJumping && !this.ridingBubble) {
                        this.dy = -PLAYER_JUMP_FORCE;
                        this.isJumping = true;
                        this.canJump = false;
                        sounds.jump();
                    }
                     if (!keys.ArrowUp) {
                        this.canJump = true;
                    }
                    this.applyPhysics();
                }

                updateAI() {
                    attractModeAI.changeDirectionTimer--;
                    if (attractModeAI.changeDirectionTimer <= 0) {
                        this.direction = this.direction === 'left' ? 'right' : 'left';
                        attractModeAI.changeDirectionTimer = 120 + Math.random() * 120;
                    }
                    this.dx = this.direction === 'left' ? -PLAYER_SPEED / 2 : PLAYER_SPEED / 2;

                    attractModeAI.jumpTimer--;
                    if (attractModeAI.jumpTimer <= 0 && !this.isJumping) {
                        this.dy = -PLAYER_JUMP_FORCE;
                        this.isJumping = true;
                        attractModeAI.jumpTimer = 180 + Math.random() * 100;
                    }

                    attractModeAI.shootTimer--;
                    if (attractModeAI.shootTimer <= 0) {
                        this.shoot();
                        attractModeAI.shootTimer = 90 + Math.random() * 60;
                    }

                    this.applyPhysics();
                }

                applyPhysics() {
                     // --- BUBBLE RIDING LOGIC ---
                    if (this.ridingBubble) {
                        if (!bubbles.includes(this.ridingBubble) || this.ridingBubble.isTrapping) {
                            this.ridingBubble = null;
                        } else {
                            this.y = (this.ridingBubble.y - this.ridingBubble.h / 2) - this.h;
                            this.x += this.ridingBubble.dx;
                            this.dy = 0;
                            this.isJumping = false;

                            if (keys.ArrowUp && this.canJump) {
                                this.dy = -PLAYER_JUMP_FORCE;
                                this.isJumping = true;
                                this.canJump = false;
                                this.ridingBubble.lifespan = 0;
                                this.ridingBubble = null;
                                sounds.jump();
                            } else if (this.x + this.w < this.ridingBubble.x - this.ridingBubble.w / 2 || this.x > this.ridingBubble.x + this.ridingBubble.w / 2) {
                                this.ridingBubble = null;
                            }
                        }
                    }

                    this.x += this.dx;

                    if (!this.ridingBubble) {
                        this.y += this.dy;
                        this.dy += GRAVITY;
                    }

                    if (this.x + this.w < 0) this.x = canvas.width;
                    if (this.x > canvas.width) this.x = -this.w;

                    platforms.forEach(p => {
                        if (checkCollision({ ...this, w: this.w, h: this.h }, p)) {
                           if (this.dy > 0 && this.y + this.h - this.dy <= p.y) {
                                this.y = p.y - this.h;
                                this.dy = 0;
                                this.isJumping = false;
                           } 
                           else if (this.dy < 0 && this.y - this.dy >= p.y + p.h) {
                                this.y = p.y + p.h;
                                this.dy = 0;
                           }
                           else if (this.x + this.w > p.x && this.x < p.x + p.w){
                               if(this.dx > 0) { this.x = p.x - this.w; } 
                               else if (this.dx < 0) { this.x = p.x + p.w; }
                           }
                        }
                    });
                    
                    if (!this.ridingBubble) {
                         for (let i = bubbles.length - 1; i >= 0; i--) {
                            const b = bubbles[i];
                            const bubbleHitbox = { x: b.x - b.w / 2, y: b.y - b.h / 2, w: b.w, h: b.h };

                            if (!b.isTrapping && this.dy > 0 && checkCollision(this, bubbleHitbox)) {
                                if ((this.y + this.h) - this.dy < bubbleHitbox.y + bubbleHitbox.h / 2) {
                                    this.ridingBubble = b;
                                    this.dy = 0;
                                    this.isJumping = false;
                                    this.y = bubbleHitbox.y - this.h;
                                    break; 
                                }
                            }
                        }
                    }

                    if (this.y > canvas.height && !attractModeAI.active) {
                       this.playerHit();
                    }

                    if (this.invincible) {
                        this.invincibleTimer--;
                        if (this.invincibleTimer <= 0) this.invincible = false;
                    }
                    
                    if (this.isShooting) {
                        this.shootTimer--;
                        if (this.shootTimer <= 0) this.isShooting = false;
                    }

                    this.setAnimationState();
                    this.animator.update();
                }

                shoot() {
                    if (bubbles.length < 5 && !this.isShooting) {
                        const bubbleX = this.direction === 'right' ? this.x + this.w : this.x;
                        const bubbleY = this.y + this.h / 2;
                        bubbles.push(new Bubble(bubbleX, bubbleY, this.direction));
                        sounds.shoot();
                        this.isShooting = true;
                        this.shootTimer = 15; // frames
                    }
                }
                
                playerHit() {
                    if (!this.invincible) {
                        lives--;
                        sounds.playerHit();
                        updateUI();
                        if (lives <= 0) {
                            isGameOver = true;
                        } else {
                            this.invincible = true;
                            this.invincibleTimer = 120;
                            this.reset();
                        }
                    }
                }
            }
            
            class Bubble {
                constructor(x, y, direction) {
                    this.x = x;
                    this.y = y;
                    this.w = 54; // 42 + 12
                    this.h = 48;
                    this.dx = direction === 'right' ? BUBBLE_SPEED : -BUBBLE_SPEED;
                    this.lifespan = BUBBLE_LIFESPAN;
                    this.isTrapping = null;
                    this.trappedAnimator = null;

                    this.animator = new Animator(this, 'bubble');
                    this.animator.setAnimation('normal');
                }
                
                draw() {
                    if (this.isTrapping && this.isTrapping.type === 'flyer' && this.trappedAnimator) {
                        this.trappedAnimator.draw(ctx, this.x - this.w / 2, this.y - this.h / 2, this.w, this.h);
                    } else {
                        this.animator.draw(ctx, this.x - this.w / 2, this.y - this.h / 2, this.w, this.h);
                    }
                }
                
                update() {
                    this.lifespan--;
                    
                    if (this.isTrapping) {
                        if (this.isTrapping.type === 'flyer' && this.trappedAnimator) {
                             this.trappedAnimator.update();
                        } else {
                            this.animator.setAnimation('trapped');
                        }

                        this.x += (Math.sin(this.lifespan / 10)) * 0.5;
                        this.y -= 0.8; 

                        if (this.y - this.h / 2 < 0) this.y = this.h / 2;
                        
                        this.isTrapping.x = this.x - this.isTrapping.w / 2;
                        this.isTrapping.y = this.y - this.isTrapping.h / 2;
                    } else {
                         this.animator.setAnimation('normal');
                         this.x += this.dx;
                         if (this.lifespan < BUBBLE_LIFESPAN - 60) {
                            this.dx = 0;
                            this.y -= 0.5;
                         }
                    }
                    this.animator.update();
                }
            }

            class Enemy {
                constructor(x, y, type = 'walker') {
                    this.w = 48;
                    this.h = 48;
                    this.x = x;
                    this.y = y;
                    this.startY = y;
                    this.type = type;
                    this.dx = 1.5;
                    this.dy = 0;
                    this.isTrapped = false;
                    this.trappedTimer = 0;
                    this.isAngry = false;
                    
                    this.animator = new Animator(this, this.type === 'flyer' ? 'flying_monster' : 'monster');
                }

                draw() {
                    if (this.isTrapped) return;
                    this.animator.draw(ctx, this.x, this.y, this.w, this.h);
                }
                
                setAnimationState() {
                    if (this.isTrapped) return;

                    const dir = this.dx > 0 ? 'Right' : 'Left';
                    let state;
                    if (this.type === 'flyer') {
                        state = this.isAngry ? 'angryFly' : 'fly';
                    } else {
                        state = this.isAngry ? 'angry' : 'walk';
                    }
                    this.animator.setAnimation(`${state}${dir}`);
                }

                update() {
                    this.setAnimationState();
                    this.animator.update();
                    
                    if (this.isTrapped) {
                        this.trappedTimer--;
                        if (this.trappedTimer <= 0) {
                            this.isTrapped = false;
                            this.isAngry = true;
                            this.dx = (this.dx > 0 ? 1 : -1) * (this.type === 'flyer' ? 3.5 : 2.5);
                            bubbles = bubbles.filter(b => b.isTrapping !== this);
                        }
                        return;
                    }

                    this.x += this.dx;

                    if (this.type === 'flyer') {
                        // Sine wave movement
                        this.y = this.startY + Math.sin(this.x / 60) * 40;
                        if (this.x < 0 || this.x + this.w > canvas.width) {
                            this.dx *= -1;
                        }
                    } else {
                        // Walker logic
                        this.dy += GRAVITY;
                        this.y += this.dy;

                        let onPlatform = false;

                        platforms.forEach(p => {
                            if (checkCollision({ ...this, w: this.w, h: this.h }, p)) {
                                if (this.dy > 0 && this.y + this.h - this.dy <= p.y) {
                                    this.y = p.y - this.h;
                                    this.dy = 0;
                                    onPlatform = true;
                                }
                            }
                        });

                        let hitScreenEdge = false;
                        if (this.x < 0) {
                            this.x = 0;
                            this.dx *= -1;
                            hitScreenEdge = true;
                        } else if (this.x + this.w > canvas.width) {
                            this.x = canvas.width - this.w;
                            this.dx *= -1;
                            hitScreenEdge = true;
                        }

                        if (onPlatform && !hitScreenEdge) {
                            const groundCheckX = this.dx > 0 ? this.x + this.w : this.x;
                            let groundAhead = false;
                            platforms.forEach(p => {
                                if (this.y + this.h === p.y && groundCheckX >= p.x && groundCheckX <= p.x + p.w) {
                                    groundAhead = true;
                                }
                            });
                            if (!groundAhead) {
                                this.dx *= -1;
                            }
                        }
                    }
                }
            }
            
            class Platform {
                constructor(x, y, w, h, color, style) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h + 16;
                    this.color = color || '#3498db';
                    this.style = style || 'solid';
                    const colorVal = parseInt(this.color.substring(1), 16);
                    
                    let r = (colorVal >> 16) & 0xff;
                    let g = (colorVal >> 8) & 0xff;
                    let b = colorVal & 0xff;
                    r = Math.floor(r * 0.75);
                    g = Math.floor(g * 0.75);
                    b = Math.floor(b * 0.75);
                    this.shadowColor = `rgb(${r}, ${g}, ${b})`;

                    r = (colorVal >> 16) & 0xff;
                    g = (colorVal >> 8) & 0xff;
                    b = colorVal & 0xff;
                    r = Math.min(255, r + 50);
                    g = Math.min(255, g + 50);
                    b = Math.min(255, b + 50);
                    this.highlightColor = `rgb(${r}, ${g}, ${b})`;
                    this.edgeDepth = 8;
                }

                draw() {
                    const d = this.edgeDepth;
                    const x = this.x;
                    const y = this.y;
                    const w = this.w;
                    const h = this.h;

                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.fillRect(x + 4, y + 4, w, h);

                    ctx.fillStyle = this.shadowColor;
                    ctx.fillRect(x, y, w, h);
                    
                    const topX = x;
                    const topY = y;
                    const topW = w - d;
                    const topH = h - d;
                    
                    ctx.fillStyle = this.color;
                    ctx.fillRect(topX, topY, topW, topH);
                    
                    this.drawPattern(topX, topY, topW, topH);
                    
                    ctx.fillStyle = this.highlightColor;
                    ctx.fillRect(x, y, topW, 4);
                }
                
                drawPattern(x, y, w, h) {
                    switch (this.style) {
                        case 'stripes':
                            ctx.fillStyle = this.shadowColor;
                            for (let i = 0; i < w; i += 20) {
                                ctx.fillRect(x + i, y, 10, h);
                            }
                            break;
                        case 'squares':
                            ctx.fillStyle = this.shadowColor;
                             for (let i = 0; i < w; i += 25) {
                                for (let j = 0; j < h; j += 25) {
                                     if ((Math.floor(i / 25) + Math.floor(j / 25)) % 2 === 0) {
                                         ctx.fillRect(x + i, y + j, 25, 25);
                                     }
                                }
                            }
                            break;
                        case 'bevel':
                             ctx.strokeStyle = this.shadowColor;
                             ctx.lineWidth = 6;
                             ctx.strokeRect(x + 3, y + 3, w - 6, h - 6);
                             break;
                        case 'dots':
                            ctx.fillStyle = this.highlightColor;
                             for (let i = 10; i < w; i += 25) {
                                for (let j = 10; j < h; j += 25) {
                                     ctx.beginPath();
                                     ctx.arc(x + i, y + j, 5, 0, Math.PI * 2);
                                     ctx.fill();
                                }
                            }
                            break;
                    }
                }
            }

            class Collectible {
                constructor(x, y, type) {
                    this.x = x;
                    this.y = y;
                    this.w = 48;
                    this.h = 48;
                    this.type = type;
                    this.points = (bonusTypes.indexOf(type) + 1) * 100 * level;
                    this.lifespan = 500;
                    this.animator = new Animator(this, 'bonus');
                    this.animator.setAnimation(this.type);
                }
                
                draw() {
                    this.animator.draw(ctx, this.x, this.y, this.w, this.h);
                }
                
                update() {
                    this.lifespan--;
                    this.animator.update();
                }
            }
            
            // --- Level Design ---
            const levelDesigns = [
                // Level 1: The Courtyard
                {
                    background: 'background_level_1',
                    platformStyle: 'squares',
                    platforms: [
                        { pos: [100, 450, 150, 20], color: '#27ae60' },
                        { pos: [550, 450, 150, 20], color: '#27ae60' },
                        { pos: [300, 350, 200, 20], color: '#2980b9' },
                        { pos: [0, 250, 200, 20], color: '#c0392b' },
                        { pos: [600, 250, 200, 20], color: '#c0392b' },
                        { pos: [300, 150, 200, 20], color: '#f39c12' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [50, 200, 'walker'], [700, 200, 'walker'], [350, 100, 'walker']
                    ]
                },
                // Level 2: The Climb
                {
                    background: 'background_level_2',
                    platformStyle: 'stripes',
                    platforms: [
                        { pos: [620, 480, 150, 20], color: '#d35400' },
                        { pos: [420, 400, 150, 20], color: '#d35400' },
                        { pos: [180, 320, 150, 20], color: '#d35400' },
                        { pos: [420, 240, 150, 20], color: '#d35400' },
                        { pos: [620, 160, 150, 20], color: '#d35400' },
                        { pos: [50, 100, 200, 20], color: '#16a085' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [670, 430, 'walker'], [470, 350, 'walker'], [230, 270, 'walker'], [100, 50, 'walker']
                    ]
                },
                // Level 3: The Gauntlet
                {
                    background: 'background_level_3',
                    platformStyle: 'bevel',
                    platforms: [
                        { pos: [0, 450, 100, 20], color: '#8e44ad' },
                        { pos: [700, 450, 100, 20], color: '#8e44ad' },
                        { pos: [150, 350, 500, 20], color: '#2c3e50' },
                        { pos: [150, 200, 100, 20], color: '#8e44ad' },
                        { pos: [550, 200, 100, 20], color: '#8e44ad' },
                        { pos: [300, 120, 200, 20], color: '#2c3e50' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [200, 300, 'walker'], [300, 300, 'walker'], [400, 300, 'walker'], [500, 300, 'walker'], [600, 300, 'walker']
                    ]
                },
                // Level 4: The Core
                {
                    background: 'background_level_4',
                    platformStyle: 'dots',
                    platforms: [
                        { pos: [0, 150, 250, 20], color: '#e74c3c' },
                        { pos: [550, 150, 250, 20], color: '#e74c3c' },
                        { pos: [0, 400, 250, 20], color: '#3498db' },
                        { pos: [550, 400, 250, 20], color: '#3498db' },
                        { pos: [375, 275, 50, 20], color: '#f1c40f' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                     enemies: [
                        [100, 100, 'walker'], [650, 100, 'walker'], [100, 350, 'walker'], [650, 350, 'walker']
                    ]
                },
                 // Level 5: The Funnel
                {
                    background: 'background_level_5',
                    platformStyle: 'bevel',
                    platforms: [
                        { pos: [0, 100, 200, 20], color: '#9b59b6' },
                        { pos: [600, 100, 200, 20], color: '#9b59b6' },
                        { pos: [100, 250, 150, 20], color: '#34495e' },
                        { pos: [550, 250, 150, 20], color: '#34495e' },
                        { pos: [200, 400, 400, 20], color: '#9b59b6' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [100, 50, 'walker'], [650, 50, 'walker'], [300, 350, 'walker'], [450, 350, 'walker'], [100, 150, 'flyer']
                    ]
                },
                // Level 6: Stepping Stones
                {
                    background: 'background_level_6',
                    platformStyle: 'dots',
                    platforms: [
                        { pos: [50, 500, 100, 20], color: '#f1c40f' },
                        { pos: [250, 450, 100, 20], color: '#f1c40f' },
                        { pos: [450, 400, 100, 20], color: '#f1c40f' },
                        { pos: [650, 350, 100, 20], color: '#f1c40f' },
                        { pos: [450, 250, 100, 20], color: '#f1c40f' },
                        { pos: [250, 200, 100, 20], color: '#f1c40f' },
                        { pos: [50, 150, 100, 20], color: '#f1c40f' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [100, 450, 'walker'], [300, 150, 'walker'], [500, 200, 'walker'], [700, 300, 'walker']
                    ]
                },
                // Level 7: The Cage
                {
                    background: 'background_level_7',
                    platformStyle: 'squares',
                    platforms: [
                        { pos: [200, 200, 400, 20], color: '#2ecc71' },
                        { pos: [200, 400, 400, 20], color: '#2ecc71' },
                        { pos: [200, 200, 20, 220], color: '#2ecc71' },
                        { pos: [580, 200, 20, 220], color: '#2ecc71' },
                        { pos: [0, 100, 150, 20], color: '#27ae60' },
                        { pos: [650, 100, 150, 20], color: '#27ae60' },
                        { pos: [100, 450, 50, 20], color: '#27ae60' },
                        { pos: [650, 450, 50, 20], color: '#27ae60' },
                        { pos: [50, 300, 50, 20], color: '#27ae60' },
                        { pos: [700, 300, 50, 20], color: '#27ae60' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [250, 150, 'walker'], [350, 150, 'walker'], [450, 150, 'walker'], [100, 50, 'walker'], [700, 50, 'walker']
                    ]
                },
                // Level 8: Twin Peaks
                {
                    background: 'background_level_8',
                    platformStyle: 'stripes',
                    platforms: [
                        { pos: [0, 400, 250, 20], color: '#e74c3c' },
                        { pos: [550, 400, 250, 20], color: '#e74c3c' },
                        { pos: [50, 250, 200, 20], color: '#c0392b' },
                        { pos: [550, 250, 200, 20], color: '#c0392b' },
                        { pos: [100, 150, 150, 20], color: '#e74c3c' },
                        { pos: [550, 150, 150, 20], color: '#e74c3c' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [150, 100, 'walker'], [600, 100, 'walker'], [350, 300, 'flyer'], [100, 350, 'walker'], [650, 350, 'walker']
                    ]
                },
                // Level 9: The Maze
                {
                    background: 'background_level_9',
                    platformStyle: 'bevel',
                    platforms: [
                        { pos: [100, 100, 250, 20], color: '#bdc3c7' }, 
                        { pos: [450, 100, 250, 20], color: '#bdc3c7' }, 
                        { pos: [100, 200, 20, 300], color: '#95a5a6' },
                        { pos: [680, 200, 20, 300], color: '#95a5a6' },
                        { pos: [200, 250, 150, 20], color: '#bdc3c7' },
                        { pos: [450, 250, 150, 20], color: '#bdc3c7' },
                        { pos: [300, 370, 200, 20], color: '#95a5a6' },
                        { pos: [200, 450, 400, 20], color: '#bdc3c7' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [150, 150, 'walker'], [600, 150, 'walker'], [350, 300, 'walker'], [250, 400, 'walker'], [500, 400, 'walker']
                    ]
                },
                // Level 10: Final Arena
                {
                    background: 'background_level_10',
                    platformStyle: 'squares',
                    platforms: [
                        { pos: [50, 150, 100, 20], color: '#e74c3c' },
                        { pos: [650, 150, 100, 20], color: '#e74c3c' },
                        { pos: [350, 250, 100, 20], color: '#f1c40f' },
                        { pos: [50, 350, 100, 20], color: '#3498db' },
                        { pos: [650, 350, 100, 20], color: '#3498db' },
                        { pos: [200, 450, 150, 20], color: '#2ecc71' },
                        { pos: [450, 450, 150, 20], color: '#2ecc71' },
                        { pos: [0, 580, 800, 20], color: '#7f8c8d' }
                    ],
                    enemies: [
                        [100, 100, 'walker'], [700, 100, 'walker'], [375, 200, 'flyer'], [100, 300, 'walker'], [700, 300, 'walker'], [250, 400, 'flyer'], [500, 400, 'flyer']
                    ]
                }
            ];

            function loadLevel(levelNum) {
                const design = levelDesigns[(levelNum - 1) % levelDesigns.length];
                currentBackground = sprites[design.background];
                platforms = [];
                enemies = [];
                bubbles = [];
                collectibles = [];
                
                design.platforms.forEach(p => platforms.push(new Platform(...p.pos, p.color, design.platformStyle)));
                design.enemies.forEach(e => enemies.push(new Enemy(...e)));
                
                if (!player) {
                    player = new Player();
                }
                player.reset();
                updateUI();
            }
            
            // --- Game Loop and Logic ---
            
            function update() {
                if (isGameOver) return; 

                if (gameStarted || attractModeAI.active) {
                    player.update();
                }
                
                if (gameStarted) {
                     for (let i = bubbles.length - 1; i >= 0; i--) {
                        const b = bubbles[i];
                        b.update();
                        if (b.lifespan <= 0) {
                             if (b.isTrapping) {
                                b.isTrapping.isTrapped = false;
                                b.isTrapping.isAngry = true;
                                b.isTrapping.dx = (b.isTrapping.dx > 0 ? 1 : -1) * (b.isTrapping.type === 'flyer' ? 3.5 : 2.5);
                            }
                            bubbles.splice(i, 1);
                        }
                    }
                    
                    enemies.forEach(e => e.update());
                    
                    for (let i = collectibles.length - 1; i >= 0; i--) {
                       const c = collectibles[i];
                       c.update();
                       if (c.lifespan <= 0) {
                           collectibles.splice(i, 1);
                       }
                    }

                    handleCollisions();
                    
                    if (enemies.length === 0 && gameStarted) {
                        gameStarted = false; 
                        sounds.levelClear();
                        let bonus = 500 * level;
                        score += bonus;
                        levelBonusEl.textContent = `Bonus: ${bonus}`;
                        levelCompleteScreen.classList.remove('hidden');
                        setTimeout(() => {
                            levelCompleteScreen.classList.add('hidden');
                            level++;
                            loadLevel(level);
                            gameStarted = true;
                        }, 2000);
                    }
                }
            }

            function handleCollisions() {
                enemies.forEach(e => {
                    if (!e.isTrapped && checkCollision(player, e)) {
                        player.playerHit();
                    }
                });
                
                bubbles.forEach(b => {
                    if (b.isTrapping) return;
                    const bubbleRect = { x: b.x - b.w / 2, y: b.y - b.h / 2, w: b.w, h: b.h };
                    enemies.forEach(e => {
                        if (!e.isTrapped && checkCollision(bubbleRect, e)) {
                            e.isTrapped = true;
                            e.trappedTimer = ENEMY_TRAPPED_DURATION;
                            b.isTrapping = e;
                            b.lifespan = ENEMY_TRAPPED_DURATION;
                            sounds.enemyHit();

                            if (e.type === 'flyer') {
                                b.trappedAnimator = new Animator(e, 'flying_monster_trapped');
                                b.trappedAnimator.setAnimation('trapped');
                            }
                        }
                    });
                });
                
                for (let i = bubbles.length - 1; i >= 0; i--) {
                    const b = bubbles[i];
                    const bubbleRect = { x: b.x - b.w / 2, y: b.y - b.h / 2, w: b.w, h: b.h };
                    if (b.isTrapping && checkCollision(player, bubbleRect)) {
                       const enemyIndex = enemies.indexOf(b.isTrapping);
                       if (enemyIndex > -1) {
                           const randomType = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
                           collectibles.push(new Collectible(enemies[enemyIndex].x, enemies[enemyIndex].y, randomType));
                           enemies.splice(enemyIndex, 1);
                           score += 200;
                           updateUI();
                           sounds.pop();
                       }
                       bubbles.splice(i, 1);
                    }
                }

                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const c = collectibles[i];
                    if (checkCollision(player, c)) {
                        score += c.points;
                        updateUI();
                        sounds.collect();
                        collectibles.splice(i, 1);
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (currentBackground && currentBackground.complete && currentBackground.naturalWidth !== 0) {
                    ctx.drawImage(currentBackground, 0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }


                platforms.forEach(p => p.draw());
                collectibles.forEach(c => c.draw());
                
                if (player) {
                    player.draw();
                }

                bubbles.forEach(b => b.draw());
                enemies.forEach(e => {
                    e.draw();
                });
            }
            
            function gameLoop() {
                update();
                draw();
                
                if(isGameOver) {
                    showGameOver();
                } else {
                    requestAnimationFrame(gameLoop);
                }
            }

            function updateUI() {
                scoreEl.textContent = `SCORE: ${score}`;
                livesEl.textContent = `LIVES: ${lives}`;
                levelEl.textContent = `LEVEL: ${level}`;
            }

            function showGameOver() {
                gameStarted = false;
                finalScoreEl.textContent = `Your Score: ${score}`;
                gameOverScreen.classList.remove('hidden');
            }

            function resetGame() {
                score = 0;
                lives = 3;
                level = 1;
                isGameOver = false;
                loadLevel(level);
                updateUI();
            }

            function startGame() {
                attractModeAI.active = false;
                const wasGameOver = isGameOver;

                Tone.start(); 
                resetGame();
                gameStarted = true;
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
                
                if (wasGameOver) {
                   requestAnimationFrame(gameLoop);
                }
            }

            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', () => {
                startGame();
            });

            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && gameStarted && !keys.Space) {
                    player.shoot();
                }
                if (keys[e.code] !== undefined) {
                    keys[e.code] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                 if (keys[e.code] !== undefined) {
                    keys[e.code] = false;
                }
            });

            // --- Initial Load ---
            loadSprites();
            loadLevel(1);
            gameLoop();
        });
    </script>
</body>
</html>

