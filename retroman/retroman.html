<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retroman</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }
        #gameContainer {
            text-align: center;
            position: relative; /* Needed for scanlines overlay */
            border-radius: 15px;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            border: 5px solid #fff;
            /* CRT Glow Effect */
            box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #00f, 0 0 40px #00f;
            display: block; /* Removes extra space below canvas */
        }
        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to go through to the canvas */
            background: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0) 100%);
            background-size: 100% 4px;
            animation: scanline-animation 10s linear infinite;
        }

        @keyframes scanline-animation {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        #ui {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            width: 640px;
            font-size: 1.5em;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Removed background and border to make the box invisible */
            padding: 40px;
            text-align: center;
            display: none;
            font-size: 2em;
            width: 80%;
            max-width: 600px;
        }
        #gameTitle {
            animation: color-cycle 4s linear infinite;
        }
        #paradeCanvas {
            background-color: transparent;
            border: none;
            box-shadow: none;
            margin-top: 20px;
            margin-bottom: 20px;
        }
      
        #messageBox button {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            margin-top: 20px;
            padding: 10px 20px;
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            cursor: pointer;
            animation: flashing-text 1.5s infinite;
        }

        @keyframes flashing-text {
            0% { border-color: #fff; box-shadow: 0 0 5px #fff; }
            50% { border-color: #ff0; box-shadow: 0 0 15px #ff0; }
            100% { border-color: #fff; box-shadow: 0 0 5px #fff; }
        }

        @keyframes color-cycle {
            0%   { color: red; }
            25%  { color: pink; }
            50%  { color: cyan; }
            75%  { color: orange; }
            100% { color: red; }
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="ui">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 3</div>
        </div>
        <div id="gameContainer">
            <canvas id="gameCanvas" width="640" height="720"></canvas>
            <div id="scanlines"></div>
        </div>
    </div>
    <div id="messageBox">
        <h1 id="gameTitle">RETROMAN</h1>
        <canvas id="paradeCanvas" width="500" height="50"></canvas>
        <button id="messageButton">Start Game</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const messageBox = document.getElementById('messageBox');
        const gameTitle = document.getElementById('gameTitle');
        const messageButton = document.getElementById('messageButton');
        const paradeCanvas = document.getElementById('paradeCanvas');
        const paradeCtx = paradeCanvas.getContext('2d');

        const TILE_SIZE = 32;

        // Maze layout (1 = wall, 0 = pellet, 2 = power pellet, 3 = empty, 4 = ghost house door)
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 0, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 3, 1, 1, 4, 4, 1, 1, 3, 1, 0, 1, 1, 1, 1],
            [3, 3, 3, 3, 0, 3, 3, 1, 3, 3, 3, 3, 1, 3, 3, 0, 3, 3, 3, 3], // Tunnel
            [1, 1, 1, 1, 0, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 3, 3, 3, 3, 3, 3, 3, 3, 1, 0, 1, 1, 1, 1],
            [1, 1, 1, 1, 0, 1, 3, 1, 1, 1, 1, 1, 1, 3, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
            [1, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 1],
            [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];
        
        const ROWS = maze.length;
        const COLS = maze[0].length;
        canvas.height = ROWS * TILE_SIZE;
        canvas.width = COLS * TILE_SIZE;


        let score = 0;
        let lives = 3;
        let level = 1;
        let pellets = [];
        let powerPellets = [];
        let ghosts = [];
        let particles = [];
        let frightenedTimer = 0;
        let fruit = null;
        let fruitSpawnTimer = 0;
        let powerUp = null;
        let powerUpSpawnTimer = 0;
        let playerSpeedBoostTimer = 0;
        let ghostFreezeTimer = 0;
        let paradeCharacters = [];

        // --- Audio Setup with .wav files ---
        const pelletSound = new Audio('pellet.wav');
        const powerPelletSound = new Audio('power_pellet.wav');
        const eatGhostSound = new Audio('eat_ghost.wav');
        const deathSound = new Audio('death.wav');
        const backgroundMusic = new Audio('music.wav');
        backgroundMusic.loop = true;
        const beginningSound = new Audio('beginning.wav');
        const fruitSound = new Audio('fruit.wav');
        const powerupSound = new Audio('powerup.wav');
        
        let musicPlaying = false;


        class Player {
            constructor(x, y, baseSpeed) {
                this.x = x;
                this.y = y;
                this.baseSpeed = baseSpeed;
                this.speed = baseSpeed;
                this.radius = TILE_SIZE / 2 - 2;
                this.mouthOpen = 0;
                this.dir = { x: 0, y: 0 };
                this.nextDir = { x: 0, y: 0 };
            }

            draw(targetCtx = ctx) {
                targetCtx.save();
                targetCtx.translate(this.x, this.y);
                const angle = Math.atan2(this.dir.y, this.dir.x);
                targetCtx.rotate(angle);
                
                targetCtx.fillStyle = playerSpeedBoostTimer > 0 ? '#FFFF00' : 'yellow';
                targetCtx.beginPath();
                const mouthAngle = (Math.sin(this.mouthOpen * Math.PI / 18) + 1) / 4;
                targetCtx.arc(0, 0, this.radius, mouthAngle * Math.PI, (2 - mouthAngle) * Math.PI);
                targetCtx.lineTo(0, 0);
                targetCtx.closePath();
                targetCtx.fill();

                if (playerSpeedBoostTimer > 0) {
                    targetCtx.strokeStyle = 'white';
                    targetCtx.lineWidth = 2;
                    targetCtx.stroke();
                }

                targetCtx.restore();
            }

            update() {
                this.mouthOpen = (this.mouthOpen + 1) % 360;

                // Handle Speed Boost
                this.speed = playerSpeedBoostTimer > 0 ? this.baseSpeed * 1.5 : this.baseSpeed;

                const currentGridX = Math.floor(this.x / TILE_SIZE);
                const currentGridY = Math.floor(this.y / TILE_SIZE);
                const centerX = currentGridX * TILE_SIZE + TILE_SIZE / 2;
                const centerY = currentGridY * TILE_SIZE + TILE_SIZE / 2;
                
                const isAtCenter = Math.abs(this.x - centerX) < this.speed / 2 && Math.abs(this.y - centerY) < this.speed / 2;

                if (isAtCenter) {
                    this.x = centerX;
                    this.y = centerY;

                    const nextGridX = currentGridX + this.nextDir.x;
                    const nextGridY = currentGridY + this.nextDir.y;
                    
                    if (this.nextDir.x !== 0 || this.nextDir.y !== 0) { 
                        if (maze[nextGridY] && maze[nextGridY][nextGridX] !== 1 && maze[nextGridY][nextGridX] !== 4) {
                            this.dir.x = this.nextDir.x;
                            this.dir.y = this.nextDir.y;
                        }
                    }

                    const currentDirGridX = currentGridX + this.dir.x;
                    const currentDirGridY = currentGridY + this.dir.y;
                    if (maze[currentDirGridY] && maze[currentDirGridY][currentDirGridX] === 1) {
                        this.dir.x = 0;
                        this.dir.y = 0;
                    }
                }

                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;

                if (this.x < -this.radius) this.x = canvas.width + this.radius;
                if (this.x > canvas.width + this.radius) this.x = -this.radius;
            }
        }
        
        class Ghost {
            constructor(x, y, color, scatterTarget) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.speed = 2.5 + (level - 1) * 0.2;
                this.radius = TILE_SIZE / 2 - 2;
                this.dir = { x: 0, y: -1 };
                this.state = 'scatter'; // chase, scatter, frightened, eaten
                this.scatterTarget = scatterTarget;
                this.eatenTimer = 0;
            }

            draw(targetCtx = ctx) {
                targetCtx.globalAlpha = ghostFreezeTimer > 0 && targetCtx === ctx ? 0.5 : 1;
                targetCtx.fillStyle = this.state === 'frightened' ? '#0000FF' : this.color;
                if(this.state === 'eaten') targetCtx.fillStyle = '#FFF';

                targetCtx.beginPath();
                targetCtx.arc(this.x, this.y, this.radius, Math.PI, 0);
                targetCtx.lineTo(this.x + this.radius, this.y + this.radius * 1.5);
                targetCtx.lineTo(this.x + this.radius * 0.5, this.y + this.radius);
                targetCtx.lineTo(this.x, this.y + this.radius * 1.5);
                targetCtx.lineTo(this.x - this.radius * 0.5, this.y + this.radius);
                targetCtx.lineTo(this.x - this.radius, this.y + this.radius * 1.5);
                targetCtx.closePath();
                targetCtx.fill();

                // Eyes
                targetCtx.fillStyle = this.state === 'frightened' ? '#FF0000' : 'white';
                targetCtx.beginPath();
                targetCtx.arc(this.x - this.radius * 0.4, this.y - this.radius * 0.2, this.radius * 0.2, 0, Math.PI * 2);
                targetCtx.arc(this.x + this.radius * 0.4, this.y - this.radius * 0.2, this.radius * 0.2, 0, Math.PI * 2);
                targetCtx.fill();

                targetCtx.fillStyle = 'black';
                const eyeDirX = player.x > this.x ? 1 : -1;
                const eyeDirY = player.y > this.y ? 1 : -1;
                targetCtx.beginPath();
                targetCtx.arc(this.x - this.radius * 0.4 + eyeDirX * 2, this.y - this.radius * 0.2 + eyeDirY * 2, this.radius * 0.1, 0, Math.PI * 2);
                targetCtx.arc(this.x + this.radius * 0.4 + eyeDirX * 2, this.y - this.radius * 0.2 + eyeDirY * 2, this.radius * 0.1, 0, Math.PI * 2);
                targetCtx.fill();
                targetCtx.globalAlpha = 1;
            }

            update() {
                if (ghostFreezeTimer > 0) return; // Frozen!

                if(this.state === 'eaten') {
                    this.eatenTimer--;
                    if(this.eatenTimer <= 0) {
                        this.state = 'chase';
                        this.x = TILE_SIZE * 9.5;
                        this.y = TILE_SIZE * 8.5;
                    }
                     return;
                }
                const target = this.getTarget();
                this.moveTowards(target);

                if (this.x < -this.radius) this.x = canvas.width + this.radius;
                if (this.x > canvas.width + this.radius) this.x = -this.radius;
            }
            
            getTarget() {
                if (this.state === 'scatter') return this.scatterTarget;
                if (this.state === 'frightened') return { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
                if (this.state === 'eaten') return {x: TILE_SIZE * 9.5, y: TILE_SIZE * 8.5};
                return { x: player.x, y: player.y };
            }

            moveTowards(target) {
                const currentGridX = Math.floor(this.x / TILE_SIZE);
                const currentGridY = Math.floor(this.y / TILE_SIZE);
                const centerX = currentGridX * TILE_SIZE + TILE_SIZE / 2;
                const centerY = currentGridY * TILE_SIZE + TILE_SIZE / 2;

                const isAtCenter = Math.abs(this.x - centerX) < this.speed / 2 && Math.abs(this.y - centerY) < this.speed / 2;

                if (isAtCenter) {
                    this.x = centerX;
                    this.y = centerY;

                    const possibleMoves = [];
                    const directions = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                    const reverseDir = { x: -this.dir.x, y: -this.dir.y };
                    
                    for(const d of directions){
                        if (d.x === reverseDir.x && d.y === reverseDir.y) continue;

                        const nextGridX = currentGridX + d.x;
                        const nextGridY = currentGridY + d.y;

                        if (nextGridY < 0 || nextGridY >= ROWS || nextGridX < 0 || nextGridX >= COLS) continue;
                        
                        const nextTile = maze[nextGridY][nextGridX];
                        let isMoveValid = (nextTile !== 1 && (nextTile !== 4 || this.state === 'eaten' || d.y === -1));
                        
                        if (isMoveValid) {
                             const nextX = nextGridX * TILE_SIZE + TILE_SIZE / 2;
                             const nextY = nextGridY * TILE_SIZE + TILE_SIZE / 2;
                             possibleMoves.push({dir: d, dist: Math.hypot(nextX - target.x, nextY - target.y)});
                        }
                    }
                    
                    if (possibleMoves.length > 0) {
                        if(this.state === 'frightened'){
                            this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)].dir;
                        } else {
                            possibleMoves.sort((a,b) => a.dist - b.dist);
                            this.dir = possibleMoves[0].dir;
                        }
                    } else {
                        this.dir = reverseDir;
                    }
                }

                this.x += this.dir.x * this.speed;
                this.y += this.dir.y * this.speed;
            }
        }
        
        class Blinky extends Ghost { 
             constructor(x, y) { super(x, y, 'red', {x: canvas.width - TILE_SIZE, y: 0}); }
             getTarget() { return this.state !== 'chase' ? super.getTarget() : {x: player.x, y: player.y}; }
        }
        class Pinky extends Ghost { 
            constructor(x, y) { super(x, y, 'pink', {x: TILE_SIZE, y: 0}); }
            getTarget() {
                if (this.state !== 'chase') return super.getTarget();
                return {x: player.x + player.dir.x * TILE_SIZE * 4, y: player.y + player.dir.y * TILE_SIZE * 4};
            }
        }
        class Inky extends Ghost { 
             constructor(x, y) { super(x, y, 'cyan', {x: canvas.width-TILE_SIZE, y: canvas.height-TILE_SIZE}); }
              getTarget() {
                if (this.state !== 'chase') return super.getTarget();
                const blinky = ghosts[0];
                const offsetX = (player.x + player.dir.x * TILE_SIZE * 2) - blinky.x;
                const offsetY = (player.y + player.dir.y * TILE_SIZE * 2) - blinky.y;
                return {x: blinky.x + offsetX * 2, y: blinky.y + offsetY * 2};
             }
        }
        class Clyde extends Ghost { 
            constructor(x, y) { super(x, y, 'orange', {x: TILE_SIZE, y: canvas.height-TILE_SIZE}); }
             getTarget() {
                if (this.state !== 'chase') return super.getTarget();
                return Math.hypot(this.x - player.x, this.y - player.y) > TILE_SIZE * 8 ? {x: player.x, y: player.y} : this.scatterTarget;
            }
        }

        class Fruit {
            constructor(x, y) { this.x = x; this.y = y; this.life = 600; }
            draw() {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(this.x - 4, this.y, 6, 0, Math.PI * 2);
                ctx.arc(this.x + 4, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#00B000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 4);
                ctx.lineTo(this.x + 2, this.y - 10);
                ctx.stroke();
            }
            update() { this.life--; }
        }

        class PowerUp {
            constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.life = 600; }
            draw() {
                if (this.type === 'speed') {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(this.x - 8, this.y - 5);
                    ctx.lineTo(this.x, this.y - 5);
                    ctx.lineTo(this.x + 8, this.y + 5);
                    ctx.lineTo(this.x - 8, this.y + 5);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'freeze') {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y - 6);
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + 4, this.y);
                    ctx.stroke();
                }
            }
            update() { this.life--; }
        }

        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.size = Math.random() * 5 + 2; this.life = 1; this.vx = Math.random() * 4 - 2; this.vy = Math.random() * 4 - 2; }
            draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
        }

        let player = new Player(TILE_SIZE * 9.5, TILE_SIZE * 15.5, 3);
        
        function initLevel() {
            pellets = [];
            powerPellets = [];
            frightenedTimer = 0;
            fruit = null;
            fruitSpawnTimer = 600; 
            powerUp = null;
            powerUpSpawnTimer = 1200; // Spawn first powerup after 20 seconds

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (maze[row][col] === 0) pellets.push({ x: col * TILE_SIZE + TILE_SIZE / 2, y: row * TILE_SIZE + TILE_SIZE / 2 });
                    else if (maze[row][col] === 2) powerPellets.push({ x: col * TILE_SIZE + TILE_SIZE / 2, y: row * TILE_SIZE + TILE_SIZE / 2, size: 8 });
                }
            }

            player.x = TILE_SIZE * 9.5;
            player.y = TILE_SIZE * 15.5;
            player.dir = {x:0, y:0};
            player.nextDir = {x:0, y:0};
            
            ghosts = [
                new Blinky(TILE_SIZE * 9.5, TILE_SIZE * 8.5),
                new Pinky(TILE_SIZE * 9.5, TILE_SIZE * 9.5),
                new Inky(TILE_SIZE * 8.5, TILE_SIZE * 9.5),
                new Clyde(TILE_SIZE * 10.5, TILE_SIZE * 9.5)
            ];
            
            ghosts.forEach(g => g.speed = 2.5 + (level - 1) * 0.2);
        }
        
        function drawMaze() {
            ctx.strokeStyle = '#0000FF';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (maze[row][col] === 1) {
                        const x = col * TILE_SIZE; const y = row * TILE_SIZE;
                        if (row === 0 || maze[row - 1][col] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + TILE_SIZE, y); ctx.stroke(); }
                        if (row === ROWS - 1 || maze[row + 1][col] !== 1) { ctx.beginPath(); ctx.moveTo(x, y + TILE_SIZE); ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE); ctx.stroke(); }
                        if (col === 0 || maze[row][col - 1] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + TILE_SIZE); ctx.stroke(); }
                        if (col === COLS - 1 || maze[row][col + 1] !== 1) { ctx.beginPath(); ctx.moveTo(x + TILE_SIZE, y); ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE); ctx.stroke(); }
                    } else if (maze[row][col] === 4) {
                        ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(col * TILE_SIZE, row * TILE_SIZE + TILE_SIZE / 2); ctx.lineTo(col * TILE_SIZE + TILE_SIZE, row * TILE_SIZE + TILE_SIZE / 2); ctx.stroke(); ctx.strokeStyle = '#0000FF';
                    }
                }
            }
        }

        function handleInput(e) {
            switch (e.key) {
                case 'ArrowUp': player.nextDir = { x: 0, y: -1 }; break;
                case 'ArrowDown': player.nextDir = { x: 0, y: 1 }; break;
                case 'ArrowLeft': player.nextDir = { x: -1, y: 0 }; break;
                case 'ArrowRight': player.nextDir = { x: 1, y: 0 }; break;
            }
        }
        
        function checkCollisions() {
            // Pellets
            for (let i = pellets.length - 1; i >= 0; i--) {
                if (Math.hypot(player.x - pellets[i].x, player.y - pellets[i].y) < player.radius) {
                    pellets.splice(i, 1); score += 10; if (pelletSound.paused) pelletSound.play();
                }
            }
            
            // Power Pellets
            for (let i = powerPellets.length - 1; i >= 0; i--) {
                const p = powerPellets[i];
                if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.size) {
                    powerPellets.splice(i, 1); score += 50; frightenedTimer = 400 - level * 20;
                    ghosts.forEach(g => { if (g.state !== 'eaten') g.state = 'frightened' });
                    powerPelletSound.play();
                }
            }

            // Fruit
            if (fruit && Math.hypot(player.x - fruit.x, player.y - fruit.y) < player.radius) {
                score += 100; fruitSound.play(); fruit = null; fruitSpawnTimer = 1200;
            }

            // PowerUp
            if (powerUp && Math.hypot(player.x - powerUp.x, player.y - powerUp.y) < player.radius) {
                score += 150; powerupSound.play();
                if (powerUp.type === 'speed') playerSpeedBoostTimer = 300; // 5 seconds
                else if (powerUp.type === 'freeze') ghostFreezeTimer = 300;
                powerUp = null;
            }

            // Ghosts
            for (const ghost of ghosts) {
                if (Math.hypot(player.x - ghost.x, player.y - ghost.y) < player.radius + ghost.radius) {
                    if (ghost.state === 'frightened') {
                        ghost.state = 'eaten'; ghost.eatenTimer = 200; score += 200; eatGhostSound.play();
                        for(let i = 0; i < 30; i++) particles.push(new Particle(ghost.x, ghost.y, ghost.color));
                    } else if (ghost.state !== 'eaten') {
                       playerDeath();
                    }
                }
            }
        }
        
        function playerDeath() {
             deathSound.play(); backgroundMusic.pause(); musicPlaying = false; lives--;
             if (lives <= 0) {
                showMessage("Game Over", "Try Again");
             } else {
                 resetAfterDeath();
             }
        }
        
        function resetAfterDeath() {
            player.x = TILE_SIZE * 9.5; player.y = TILE_SIZE * 15.5; player.dir = {x:0, y:0}; player.nextDir = {x:0, y:0};
            const ghostStarts = [ { x: TILE_SIZE * 9.5, y: TILE_SIZE * 8.5 }, { x: TILE_SIZE * 9.5, y: TILE_SIZE * 9.5 }, { x: TILE_SIZE * 8.5, y: TILE_SIZE * 9.5 }, { x: TILE_SIZE * 10.5, y: TILE_SIZE * 9.5 } ];
            ghosts.forEach((g, i) => { g.x = ghostStarts[i].x; g.y = ghostStarts[i].y; g.state = 'scatter'; g.dir = { x: 0, y: -1 }; });
        }
        
        function updateUI() {
            scoreElement.textContent = `SCORE: ${score}`;
            livesElement.textContent = `LIVES: ${lives}`;
        }
        
        function showMessage(text, buttonText) {
            gameTitle.textContent = text;
            messageButton.textContent = buttonText;
            messageBox.style.display = 'block';
            if (text === "RETROMAN") {
                initTitleScreen();
                paradeCanvas.style.display = 'block';
            } else {
                paradeCanvas.style.display = 'none';
            }
            gameRunning = false;
        }

        function initTitleScreen() {
            paradeCharacters = [];
            const paradePlayer = new Player(0, paradeCanvas.height / 2, 2);
            paradePlayer.dir = {x: 1, y: 0};
            paradeCharacters.push(paradePlayer);

            const colors = ['red', 'pink', 'cyan', 'orange'];
            for(let i = 0; i < colors.length; i++) {
                const ghost = new Ghost( - (i + 1) * 60, paradeCanvas.height / 2, colors[i]);
                ghost.speed = 2;
                ghost.dir = {x: 1, y: 0};
                ghost.state = 'chase'; // Ensure they don't use scatter logic
                paradeCharacters.push(ghost);
            }
        }

        function updateAndDrawTitleScreen() {
            paradeCtx.clearRect(0, 0, paradeCanvas.width, paradeCanvas.height);
            for (const char of paradeCharacters) {
                char.x += char.speed;
                if (char.x > paradeCanvas.width + 30) {
                    char.x = -30;
                }
                char.draw(paradeCtx);
            }
        }
        
        messageButton.addEventListener('click', () => {
             if (messageButton.textContent === "Start Game" || messageButton.textContent === "Try Again") beginningSound.play();
             messageBox.style.display = 'none';
             if (lives <= 0) { score = 0; lives = 3; level = 1; }
             initLevel();
             gameRunning = true;
        });

        let gameRunning = false;

        function gameLoop() {
            if (gameRunning) {
                if (!musicPlaying) { backgroundMusic.play(); musicPlaying = true; }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMaze();
                
                // --- Update and Draw All Items ---
                ctx.fillStyle = 'white';
                for (const pellet of pellets) { ctx.beginPath(); ctx.arc(pellet.x, pellet.y, 3, 0, Math.PI * 2); ctx.fill(); }
                for (const p of powerPellets) { p.size = Math.sin(Date.now() * 0.005) * 2 + 8; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }
                
                if (fruit) {
                    fruit.update();
                    if (fruit.life <= 0) {
                        fruit = null;
                        fruitSpawnTimer = 1200;
                    } else {
                        fruit.draw();
                    }
                } else if (fruitSpawnTimer > 0 && --fruitSpawnTimer === 0) {
                    fruit = new Fruit(TILE_SIZE * 9.5, TILE_SIZE * 11.5);
                }
                
                if (powerUp) {
                    powerUp.update();
                    if (powerUp.life <= 0) {
                        powerUp = null;
                    } else {
                        powerUp.draw();
                    }
                } else if (powerUpSpawnTimer > 0 && --powerUpSpawnTimer === 0) {
                    powerUp = new PowerUp(TILE_SIZE * 1.5, TILE_SIZE * 15.5, Math.random() < 0.5 ? 'speed' : 'freeze');
                }
                
                player.update();
                player.draw();

                ghosts.forEach(ghost => { ghost.update(); ghost.draw(); });

                // Update Timers
                if (frightenedTimer > 0) { if (--frightenedTimer === 0) ghosts.forEach(g => { if(g.state === 'frightened') g.state = 'chase' }); }
                if (playerSpeedBoostTimer > 0) playerSpeedBoostTimer--;
                if (ghostFreezeTimer > 0) ghostFreezeTimer--;

                // Update and Draw Particles
                for(let i = particles.length - 1; i >= 0; i--) { particles[i].update(); particles[i].draw(); if(particles[i].life <= 0) particles.splice(i, 1); }

                checkCollisions();
                updateUI();

                if (pellets.length === 0 && powerPellets.length === 0) {
                    level++; backgroundMusic.pause(); musicPlaying = false; showMessage(`Level ${level}`, "Start Level");
                }
            } else if (messageBox.style.display === 'block' && gameTitle.textContent === 'RETROMAN') {
                updateAndDrawTitleScreen();
            }
             
            requestAnimationFrame(gameLoop);
        }
        
        window.addEventListener('keydown', handleInput);
        
        showMessage("RETROMAN", "Start Game");
        updateUI();
        initLevel();
        gameLoop(); // Start the main loop immediately
    </script>
</body>
</html>

